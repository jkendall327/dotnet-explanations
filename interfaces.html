<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Interfaces</title>
        <style>
</style>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="interfaces">Interfaces</h1>
<p><a href="intro.html">Home</a></p>
<h2 id="in-a-nutshell">In a nutshell</h2>
<p>Interfaces let you say what you want your code to do without specifying how it does it.</p>
<h2 id="why-care-about-interfaces">Why care about interfaces?</h2>
<p>Interfaces seem very abstract and unnecessary at first. They are, however, a very useful way to make your code more flexible and maintainable. (Buzzword counter: 2.)</p>
<p>Don't go looking for situations where you can use interfaces. If you use an interface in every single situation where you can, you will make your project more complicated for no reason.</p>
<p>You will end up working with interfaces a lot in .NET, if only due to LINQ. Understanding what an interface is will make the age-old question 'what is the difference between <code>IEnumerable&lt;&gt;</code> and <code>List&lt;&gt;</code>?' a lot easier to understand.</p>
<h2 id="the-problem">The problem</h2>
<p>Interfaces are a solution to a problem. I will explain this problem to explain interfaces.</p>
<p>Imagine a program that lets people register user-accounts and edit their details. You might have a method that looks like this.</p>
<pre><code><code><div>public void ChangeUsername(int userID, string newName)
{
    var user = UserDetailsDatabaseLoader.Load(id);
    user.Name = newName;
}
</div></code></code></pre>
<p>We use some kind of class named <code>UserDetailsDatabaseLoader</code> to get the user's details, presumably from a database. How <code>UserDetailsDatabaseLoader</code> works doesn't matter. The important idea is that it's a 'service': it does something useful for us.</p>
<p>Now imagine that your boss comes into the office and says 'we're not using databases anymore; we're loading all user information from the filesystem'. OK, this won't be hard to change.</p>
<pre><code><code><div>public void ChangeUsername(int userID, string newName)
{
    var user = UserDetailsFilesystemLoader.Load(id);
    user.Name = newName;
}
</div></code></code></pre>
<p>We now have a different service, <code>UserDetailsFilesystemLoader</code>. It does the same thing (gets us a user's details) but does it in a different way (loading them from the filesystem, rather than a database).</p>
<p>Now imagine that your boss comes into the office and says 'we're not using the filesystem anymore; we're getting all user information from <a href="https://en.wikipedia.org/wiki/Homing_pigeon">carrier pigeons</a>'.</p>
<pre><code><code><div>public void ChangeUsername(int userID, string newName)
{
    var user = UserDetailsHomingPigeonLoader.Load(id);
    user.Name = newName;
}
</div></code></code></pre>
<p>This is getting annoying. All of these <code>Loader</code>s have done the same thing - get user information. If there was a way to express just that idea, without specifying how it's done, we wouldn't have to change <code>ChangeUsername</code> in the future.</p>
<p>This is the problem that interfaces solve.</p>
<h2 id="the-solution">The solution</h2>
<p>An interface is a list of method signatures. If you don't know what a method signature is, I talk about them in the explanation on <a href="delegates.html">delegates</a>.</p>
<p>Here is an example of an interface.</p>
<pre><code><code><div>interface ILoader
{
    public User Load(int id);
}
</div></code></code></pre>
<p>An interface looks very similar to a class. There are two main differences:</p>
<ul>
<li>You use the <code>interface</code> keyword.</li>
<li>You only define method signatures. You cannot define fields or method bodies in an interface.</li>
</ul>
<p>(Advanced note: you can actually define <a href="https://www.infoq.com/articles/default-interface-methods-cs8/">interface method bodies</a> from C# 8.0 onwards. You should not do this until you understand why the feature is available.)</p>
<p>By themselves, interfaces are useless. You can't use the <code>new</code> keyword to create an interface in your code.</p>
<p>Classes, however, can 'implement' an interface. The syntax for doing this is very similar to class-inheritance.</p>
<pre><code><code><div>class UserDetailsHomingPigeonLoader : ILoader
{
    // class implementation...
}
</div></code></code></pre>
<p>When a class implements an interface, it has to include all of the interface's method signatures. Because <code>ILoader</code> defines a method called 'Load' that takes an <code>int</code> and returns a <code>User</code>, that means <code>UserDetailsHomingPigeonLoader</code> has to do the same thing.</p>
<pre><code><code><div>class UserDetailsHomingPigeonLoader : ILoader
{
    // Without this method, your program will no longer compile.
    public User Load(int id)
    {
        // catch the bird, read the message on its leg...
    }
}
</div></code></code></pre>
<p>Imagine that you modified the other classes for getting user information in the same way, so that they all implemented <code>ILoader</code>.</p>
<p>We can now return to our original method and make an important change.</p>
<p>public void ChangeUsername(int userID, string newName)
{
var user = ILoader.Load(id);
<a href="http://user.Name">user.Name</a> = newName;
}</p>

    </body>
    </html>