<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Delegates - &lsqb;Home&rsqb;&lpar;index&period;md&rpar;</title>
        <style>
</style>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="delegates---home">Delegates - <a href="index.html">Home</a></h1>
<ul>
<li><a href="#delegates---home">Delegates - Home</a>
<ul>
<li><a href="#in-a-nutshell">In a nutshell</a></li>
<li><a href="#explanation">Explanation</a></li>
<li><a href="#method-signatures">Method signatures</a></li>
<li><a href="#using-delegates">Using delegates</a></li>
<li><a href="#actually-using-a-delegate">Actually using a delegate</a></li>
<li><a href="#treating-methods-like-variables">Treating methods like variables</a></li>
<li><a href="#other-syntax-that-you-might-see">Other syntax that you might see</a></li>
<li><a href="#multicast-delegates">Multicast delegates</a></li>
<li><a href="#why-care-about-delegates">Why care about delegates?</a></li>
<li><a href="#further-learning">Further learning</a></li>
</ul>
</li>
</ul>
<h2 id="in-a-nutshell">In a nutshell</h2>
<p>A delegate is like a <code>List&lt;&gt;</code> for methods.</p>
<h2 id="explanation">Explanation</h2>
<p>Think about a <code>List&lt;int&gt;</code>:</p>
<pre><code><code><div>var myList = new List&lt;int&gt;() {4, 6, 1, 10, 11};
</div></code></code></pre>
<p>Using a <code>List&lt;&gt;</code> lets you group several values together into one variable. This lets you do things to all of them at once -- with a <code>List&lt;int&gt;</code>, you can <code>Sum()</code> the list with a single command.</p>
<p>An important thing about a <code>List&lt;int&gt;</code> is that you can only put <code>ints</code> in it. If you put in a <code>double</code> or a <code>string</code>, the C# compiler will tell you that you've made a mistake right away. This is type-safety, and stops you from making silly mistakes.</p>
<p>A delegate is like a <code>List&lt;&gt;</code> for methods.</p>
<p>With a delegate, you can group methods into one variable. This lets you do things with all of them at once.</p>
<p>A delegate is type-safe, like a <code>List&lt;&gt;</code>. When you make a delegate, you have to say what kind of methods it accepts. If you then put in another kind of method, the C# compiler will tell you that you've made a mistake right away.</p>
<p>But how do you decide what 'kind' of methods this list should contain? To understand that, we need to understand method signatures.</p>
<h2 id="method-signatures">Method signatures</h2>
<p>Consider the following method.</p>
<pre><code><code><div>public int AddThenSquare(int x, int y)
{
    var sum = x + y;
    return sum * sum;
}
</div></code></code></pre>
<p>When you're learning C#, you focus on what's between the curly braces. This is the <em>body</em> of the method.</p>
<p>But for delegates, we care about the signature, which is the bit at the top.</p>
<p><code>public int AddThenSquare(int x, int y)</code></p>
<p>Only two parts of the signature matter for delegates:</p>
<ul>
<li>The arguments.</li>
<li>The return type.</li>
</ul>
<p>For two methods to go in the same delegate, they need to have the same arguments and return type.
The name of the method and its visibility (whether it's <code>public</code> or <code>private</code>) aren't important.</p>
<p>The <em>arguments</em> are the variables the method asks for. More specifically, we only care about the types of the arguments. It doesn't matter that <code>AddThenSquare</code> names one argument 'x' and the other 'y'. All that matters is that they are both <code>int</code>s.</p>
<p>The return type is what the method gives back. In this case, it's also an <code>int</code>. But it could be <code>void</code>, or anything else.</p>
<p>(Advanced note: the CLR can differentiate methods based on just their return type, but C# chooses not to support this.)</p>
<p>If we want to add <code>AddThenSquare</code> to a delegate, we need a delegate that says 'I will take in any method that accepts two <code>int</code>s and gives back one <code>int</code>'.</p>
<h2 id="using-delegates">Using delegates</h2>
<p>We have to define the methods our delegate accepts before we can use it.</p>
<pre><code><code><div>    delegate int ExampleDelegate(int x, int y);
</div></code></code></pre>
<p>This looks very similar to defining a method. There are two differences:</p>
<ul>
<li>We use the <code>delegate</code> keyword at the start.</li>
<li>Instead of adding a method body, we put a <code>;</code> after the arguments.</li>
</ul>
<p>We can now add methods to our delegate.</p>
<pre><code><code><div>class MyExampleClass
{
    public int AddThenSquare(int x, int y)
    {
        var sum = x + y;
        return sum * sum;
    }

    delegate int ExampleDelegate(int x, int y);

    public void MyMethod()
    {
        var myDelegate = new ExampleDelegate(AddThenSquare);
    }
}
</div></code></code></pre>
<p>This class has a method, a delegate, and another method which uses them both.</p>
<p><code>delegate int ExampleDelegate(int x, int y);</code> defines a <em>kind</em> of delegate.</p>
<p><code>var myDelegate = new ExampleDelegate(AddThenSquare);</code> creates an <em>instance</em> of the delegate we defined.</p>
<p>(Advanced note: we could actually define our delegate outside of <code>MyExampleClass</code>. This is because behind the scenes, all delegates are actually classes.)</p>
<p><code>myDelegate</code> now contains <code>AddThenSquare</code>. Because delegates are like <code>List&lt;&gt;</code>s, we can add multiple methods to it.</p>
<pre><code><code><div>class MyExampleClass
{
    public int AddThenSquare(int x, int y)
    {
        var sum = x + y;
        return sum * sum;
    }

    public int SubtractThenSquare(int x, int y)
    {
        var sum = x + y;
        return sum * sum;
    }

    delegate int ExampleDelegate(int x, int y);

    public void MyMethod()
    {
        var myDelegate = new ExampleDelegate(AddThenSquare);
        myDelegate += SubtractThenSquare;
    }
}
</div></code></code></pre>
<p><code>myDelegate</code> now contains both methods. You can remove a method from a delegate by using <code>-=</code>.</p>
<p>(Advanced note: the <code>+=</code> syntax is shorthand for the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.delegate.combine?view=net-5.0">Delegate.Combine</a> method.)</p>
<h2 id="actually-using-a-delegate">Actually using a delegate</h2>
<p>Nothing happens when you just add methods to a delegate, in the same way nothing happens when you add numbers to a <code>List&lt;int&gt;</code>.</p>
<p>To make our delegate do something, we use the delegate's <code>Invoke</code> method.
We defined our delegate as taking two <code>int</code>s, so we have to give it two <code>int</code>s to invoke it. It will also give us one <code>int</code> back, since that's how we defined it.</p>
<p><code>myDelegate.Invoke(4, 5);</code></p>
<p>This will run through every method in <code>myDelegate</code>, giving them each the arguments 4 and 5. We're not doing anything with the return values (81 and 1, in this example), but we could if we wanted.</p>
<h2 id="treating-methods-like-variables">Treating methods like variables</h2>
<p>People care about delegates because they let us treat methods like variables. More specifically, we can pass a method into another method.</p>
<pre><code><code><div>    delegate void ExampleDelegate(int x);

    public void DoTheMethodTwice(ExampleDelegate method, int argument)
    {
        method.Invoke(argument);
        method.Invoke(argument);
    }
</div></code></code></pre>
<p>This method does something with a delegate, without any knowledge of what methods the delegate actually contains.</p>
<p>(Advanced note: in fact, the delegate might be <code>null</code> and not contain any methods at all. If so, calling <code>Invoke</code> will crash the program.)</p>
<p>Delegates let us write <em>methods about methods</em>.</p>
<h2 id="other-syntax-that-you-might-see">Other syntax that you might see</h2>
<p>Writing <code>.Invoke()</code> all the time is annoying, so C# has a shorthand.</p>
<pre><code><code><div>    delegate void ExampleDelegate(int x);

    public void DoTheMethodTwice(ExampleDelegate method, int argument)
    {
        method(argument);
        method(argument);
    }
</div></code></code></pre>
<p>I don't use this syntax. It looks identical to calling a normal method, and delegates should be treated differently than methods.
You are welcome to use this syntax, just be careful with it.</p>
<p>You will also see something like this.</p>
<p><code>method?.Invoke(argument);</code></p>
<p>The question mark is the <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-">null-conditional operator</a>. Basically, it stops your program crashing if you use an empty delegate. You have to use <code>.Invoke</code> if you use the null-conditional operator.</p>
<h2 id="multicast-delegates">Multicast delegates</h2>
<p>I've used the metaphor of a <code>List</code> throughout this page. But there's a difference between a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.delegate?view=net-5.0"><code>System.Delegate</code></a> and a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.multicastdelegate?view=net-5.0"><code>System.Delegate.MulticastDelegate</code></a>.</p>
<p><code>System.Delegate</code> can only hold one method at a time. Only the <code>MulticastDelegate</code> can contain multiple methods.
The reason it's called 'multicast' is because when you add a delegate to one, it technically creates a new copy
The reason for this split is historical. When you use the <code>delegate</code> keyword, it will always be the <code>MulticastDelegate</code>.</p>
<h2 id="why-care-about-delegates">Why care about delegates?</h2>
<p>When you first learn about them, it's hard to imagine where delegates would be useful.</p>
<p>You won't create many delegates yourself. Microsoft has created convenient shortcuts for the most common use-cases, like lambda expressions, events, <code>Action&lt;&gt;</code> and <code>Func&lt;&gt;</code>. Learning about those topics will  make delegates easier to understand in retrospect.</p>
<p>More broadly, delegates are the basis of functional programming in C#. This page isn't the place to explain functional programming, but just know that it's an important topic.</p>
<h2 id="further-learning">Further learning</h2>
<p>The best explanation of delegates is <a href="https://www.youtube.com/playlist?list=PLAE7FECFFFCBE1A54">Jamie King's YouTube playlist</a>. You should watch this entire playlist.</p>

    </body>
    </html>